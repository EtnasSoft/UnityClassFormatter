using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

class Program {
  static void Main(string[] args) {
    if (args.Length != 1) {
      Console.WriteLine("Usage: ClassFormatter <file.cs>");
      return;
    }

    string filePath = args[0];
    if (!File.Exists(filePath)) {
      Console.WriteLine("File not found.");
      return;
    }

    string code = File.ReadAllText(filePath);
    SyntaxTree tree = CSharpSyntaxTree.ParseText(code);
    var rewriter = new ClassReorderRewriter();
    SyntaxNode newRoot = rewriter.Visit(tree.GetRoot());
    string newCode = newRoot.ToFullString();
    File.WriteAllText(filePath, newCode);
    Console.WriteLine("File reformatted.");
  }
}

class ClassReorderRewriter : CSharpSyntaxRewriter {
  private class MemberInfo {
    public MemberDeclarationSyntax Node { get; set; }
    public int AccessOrder { get; set; }
    public string Name { get; set; }

    public MemberInfo(MemberDeclarationSyntax node, int accessOrder, string name) {
      Node = node;
      AccessOrder = accessOrder;
      Name = name;
    }
  }

  public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node) {
    var constantFields = new List<MemberInfo>();
    var staticFields = new List<MemberInfo>();
    var fields = new List<MemberInfo>();
    var constructors = new List<MemberInfo>();
    var properties = new List<MemberInfo>();
    var eventsDelegates = new List<MemberInfo>();
    var lifeCycleMethods = new List<MemberInfo>();
    var publicMethods = new List<MemberInfo>();
    var privateMethods = new List<MemberInfo>();
    var nestedTypes = new List<MemberInfo>();

    foreach (var member in node.Members) {
      var acc = GetAccessibility(member.Modifiers);
      int accessOrder = GetAccessOrder(acc);
      string name = GetName(member);

      switch (member) {
        case FieldDeclarationSyntax fd:
          if (fd.Modifiers.Any(m => m.IsKind(SyntaxKind.ConstKeyword)))
            constantFields.Add(new MemberInfo(fd, accessOrder, name));
          else if (fd.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword)))
            staticFields.Add(new MemberInfo(fd, accessOrder, name));
          else
            fields.Add(new MemberInfo(fd, accessOrder, name));
          break;
        case PropertyDeclarationSyntax p:
          properties.Add(new MemberInfo(p, accessOrder, name));
          break;
        case ConstructorDeclarationSyntax c:
          constructors.Add(new MemberInfo(c, accessOrder, name));
          break;
        case MethodDeclarationSyntax m:
          var methodName = m.Identifier.Text;
          if (new[] { "Awake", "OnEnable", "OnDisable", "OnDestroy" }.Contains(methodName))
            lifeCycleMethods.Add(new MemberInfo(m, accessOrder, methodName));
          else {
            if (acc == Accessibility.Public || acc == Accessibility.Internal)
              publicMethods.Add(new MemberInfo(m, accessOrder, methodName));
            else
              privateMethods.Add(new MemberInfo(m, accessOrder, methodName));
          }
          break;
        case EventDeclarationSyntax e:
          eventsDelegates.Add(new MemberInfo(e, accessOrder, name));
          break;
        case DelegateDeclarationSyntax d:
          eventsDelegates.Add(new MemberInfo(d, accessOrder, name));
          break;
        case EventFieldDeclarationSyntax efd:
          eventsDelegates.Add(new MemberInfo(efd, accessOrder, name));
          break;
        case ClassDeclarationSyntax cd:
        case StructDeclarationSyntax sd:
        case InterfaceDeclarationSyntax id:
        case EnumDeclarationSyntax ed:
          nestedTypes.Add(new MemberInfo(member, accessOrder, name));
          break;
        default:
          // Keep other members at the end, but for simplicity, add to fields
          fields.Add(new MemberInfo(member, accessOrder, name));
          break;
      }
    }

    // Sort each list
    constantFields = constantFields.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    staticFields = staticFields.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    fields = fields.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    constructors = constructors.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    properties = properties.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    eventsDelegates = eventsDelegates.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    lifeCycleMethods = lifeCycleMethods.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    publicMethods = publicMethods.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    privateMethods = privateMethods.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();
    nestedTypes = nestedTypes.OrderBy(x => x.AccessOrder).ThenBy(x => x.Name).ToList();

    // Combine
    var newMembers = new SyntaxList<MemberDeclarationSyntax>();
    foreach (var mi in constantFields.Concat(staticFields).Concat(fields).Concat(constructors).Concat(properties).Concat(eventsDelegates).Concat(lifeCycleMethods).Concat(publicMethods).Concat(privateMethods).Concat(nestedTypes)) {
      newMembers = newMembers.Add(mi.Node);
    }

    // Add other members if any, but for now assume all categorized
    // foreach (var member in node.Members) {
    //   if (!newMembers.Contains(member))
    //     // add at end
    //     newMembers = newMembers.Add(member);
    // }

    return node.WithMembers(newMembers);
  }

  private int GetAccessOrder(Accessibility acc) {
    switch (acc) {
      case Accessibility.Public: return 0;
      case Accessibility.Internal: return 1;
      case Accessibility.Protected: return 2;
      case Accessibility.Private: return 3;
      case Accessibility.ProtectedAndInternal: return 1; // treat as internal or adjust if needed
      default: return 3;
    }
  }

  private Accessibility GetAccessibility(SyntaxTokenList modifiers) {
    if (modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)))
      return Accessibility.Public;
    if (modifiers.Any(m => m.IsKind(SyntaxKind.InternalKeyword)) && modifiers.Any(m => m.IsKind(SyntaxKind.ProtectedKeyword)))
      return Accessibility.ProtectedAndInternal;
    if (modifiers.Any(m => m.IsKind(SyntaxKind.InternalKeyword)))
      return Accessibility.Internal;
    if (modifiers.Any(m => m.IsKind(SyntaxKind.ProtectedKeyword)))
      return Accessibility.Protected;
    if (modifiers.Any(m => m.IsKind(SyntaxKind.PrivateKeyword)))
      return Accessibility.Private;
    return Accessibility.Private; // default
  }

  private string GetName(MemberDeclarationSyntax member) {
    switch (member) {
      case FieldDeclarationSyntax fd:
        return fd.Declaration.Variables.FirstOrDefault()?.Identifier.Text ?? "";
      case PropertyDeclarationSyntax p:
        return p.Identifier.Text;
      case ConstructorDeclarationSyntax c:
        return c.Identifier.Text;
      case MethodDeclarationSyntax m:
        return m.Identifier.Text;
      case EventDeclarationSyntax e:
        return e.Identifier.Text;
      case DelegateDeclarationSyntax d:
        return d.Identifier.Text;
      case EventFieldDeclarationSyntax efd:
        return efd.Declaration.Variables.FirstOrDefault()?.Identifier.Text ?? "";
      case ClassDeclarationSyntax cd:
        return cd.Identifier.Text;
      case StructDeclarationSyntax sd:
        return sd.Identifier.Text;
      case InterfaceDeclarationSyntax id:
        return id.Identifier.Text;
      case EnumDeclarationSyntax ed:
        return ed.Identifier.Text;
      default:
        return "";
    }
  }
}
